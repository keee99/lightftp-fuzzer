        -:    0:Source:../ftpserv.c
        -:    0:Graph:ftpserv.gcno
        -:    0:Data:ftpserv.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: * ftpserv.c
        -:    3: *
        -:    4: *  Created on: Aug 20, 2016
        -:    5: *
        -:    6: *  Modified on: Jan 29, 2023
        -:    7: *
        -:    8: *      Author: lightftp
        -:    9: */
        -:   10:
        -:   11:#include "ftpserv.h"
        -:   12:#include "cfgparse.h"
        -:   13:#include "x_malloc.h"
        -:   14:#include "fspathtools.h"
        -:   15:
        -:   16:static const FTPROUTINE_ENTRY ftpprocs[MAX_CMDS] = {
        -:   17:        {"USER", ftpUSER}, {"QUIT", ftpQUIT}, {"NOOP", ftpNOOP}, {"PWD",  ftpPWD },
        -:   18:        {"TYPE", ftpTYPE}, {"PORT", ftpPORT}, {"LIST", ftpLIST}, {"CDUP", ftpCDUP},
        -:   19:        {"CWD",  ftpCWD }, {"RETR", ftpRETR}, {"ABOR", ftpABOR}, {"DELE", ftpDELE},
        -:   20:        {"PASV", ftpPASV}, {"PASS", ftpPASS}, {"REST", ftpREST}, {"SIZE", ftpSIZE},
        -:   21:        {"MKD",  ftpMKD }, {"RMD",  ftpRMD }, {"STOR", ftpSTOR}, {"SYST", ftpSYST},
        -:   22:        {"FEAT", ftpFEAT}, {"APPE", ftpAPPE}, {"RNFR", ftpRNFR}, {"RNTO", ftpRNTO},
        -:   23:        {"OPTS", ftpOPTS}, {"MLSD", ftpMLSD}, {"AUTH", ftpAUTH}, {"PBSZ", ftpPBSZ},
        -:   24:        {"PROT", ftpPROT}, {"EPSV", ftpEPSV}, {"HELP", ftpHELP}, {"SITE", ftpSITE}
        -:   25:};
        -:   26:
        -:   27:void *mlsd_thread(PTHCONTEXT tctx);
        -:   28:void *list_thread(PTHCONTEXT tctx);
        -:   29:int list_sub (char *dirname, SOCKET s, gnutls_session_t session, struct dirent *entry);
        -:   30:int mlsd_sub (char *dirname, SOCKET s, gnutls_session_t session, struct dirent *entry);
        -:   31:void *append_thread(PTHCONTEXT tctx);
        -:   32:void *stor_thread(PTHCONTEXT tctx);
        -:   33:void *retr_thread(PTHCONTEXT tctx);
        -:   34:
        -:   35:/*
        -:   36: * FTP_PASSCMD_INDEX
        -:   37: * must be in sync with ftpprocs "PASS" index
        -:   38: */
        -:   39:#define FTP_PASSCMD_INDEX   13
        -:   40:
        -:   41:unsigned int g_newid = 0, g_threads = 0;
        -:   42:unsigned long long int g_client_sockets_created = 0, g_client_sockets_closed = 0;
        -:   43:
    #####:   44:static void cleanup_handler(void *arg)
        -:   45:{
    #####:   46:    PTHCONTEXT tctx = (PTHCONTEXT)arg;
        -:   47:
    #####:   48:    pthread_mutex_unlock(&tctx->context->MTLock);
    #####:   49:    free(tctx);
    #####:   50:}
        -:   51:
    #####:   52:ssize_t sendstring_plaintext(SOCKET s, const char *Buffer)
        -:   53:{
    #####:   54:    return (send(s, Buffer, strlen(Buffer), MSG_NOSIGNAL) >= 0);
        -:   55:}
        -:   56:
      100:   57:void ftp_shutdown_tls_session(gnutls_session_t session)
        -:   58:{
      100:   59:    if (session != NULL) {
    #####:   60:        gnutls_bye(session, GNUTLS_SHUT_RDWR);
    #####:   61:        gnutls_deinit(session);
        -:   62:    }
      100:   63:}
        -:   64:
    #####:   65:int ftp_init_tls_session(gnutls_session_t *session, SOCKET s, int send_status)
        -:   66:{
    #####:   67:    int					ret;
    #####:   68:    gnutls_session_t	nsession = NULL;
        -:   69:
    #####:   70:    if (session == NULL)
        -:   71:        return 0;
        -:   72:
    #####:   73:    if (gnutls_init(&nsession, GNUTLS_SERVER | GNUTLS_NO_SIGNAL) < 0)
        -:   74:        return 0;
        -:   75:
    #####:   76:    while (nsession)
        -:   77:    {
    #####:   78:        if (gnutls_priority_set(nsession, priority_cache) < 0)
        -:   79:            break;
        -:   80:
    #####:   81:        if (gnutls_credentials_set(nsession, GNUTLS_CRD_CERTIFICATE, x509_cred) < 0)
        -:   82:            break;
        -:   83:
    #####:   84:        gnutls_certificate_server_set_request(nsession, GNUTLS_CERT_IGNORE);
    #####:   85:        gnutls_handshake_set_timeout(nsession, GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT);
    #####:   86:        gnutls_transport_set_int2(nsession, s, s);
    #####:   87:        gnutls_session_ticket_enable_server(nsession, &session_keys_storage);
        -:   88:
    #####:   89:        if (send_status)
    #####:   90:            sendstring_plaintext(s, success234);
        -:   91:
    #####:   92:        do {
    #####:   93:            ret = gnutls_handshake(nsession);
    #####:   94:        } while ((ret < 0) && (gnutls_error_is_fatal(ret) == 0));
        -:   95:
    #####:   96:        if (ret < 0)
        -:   97:            break;
        -:   98:
    #####:   99:        *session = nsession;
    #####:  100:        return 1;
        -:  101:    }
        -:  102:
    #####:  103:    gnutls_deinit(nsession);
        -:  104:
    #####:  105:    if (send_status)
    #####:  106:        sendstring_plaintext(s, error500_auth);
        -:  107:
        -:  108:    return 0;
        -:  109:}
        -:  110:
    #####:  111:SOCKET create_datasocket(PFTPCONTEXT context)
        -:  112:{
    #####:  113:    SOCKET				clientsocket = INVALID_SOCKET;
    #####:  114:    struct sockaddr_in	laddr;
    #####:  115:    socklen_t			asz;
        -:  116:
    #####:  117:    memset(&laddr, 0, sizeof(laddr));
        -:  118:
    #####:  119:    switch ( context->Mode ) {
    #####:  120:    case MODE_NORMAL:
    #####:  121:        clientsocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    #####:  122:        context->DataSocket = clientsocket;
    #####:  123:        if ( clientsocket == INVALID_SOCKET )
        -:  124:            return INVALID_SOCKET;
        -:  125:
    #####:  126:        laddr.sin_family = AF_INET;
    #####:  127:        laddr.sin_port = context->DataPort;
    #####:  128:        laddr.sin_addr.s_addr = context->DataIPv4;
    #####:  129:        if ( connect(clientsocket, (const struct sockaddr *)&laddr, sizeof(laddr)) == -1 ) {
    #####:  130:            close(clientsocket);
    #####:  131:            return INVALID_SOCKET;
        -:  132:        }
        -:  133:        break;
        -:  134:
    #####:  135:    case MODE_PASSIVE:
    #####:  136:        asz = sizeof(laddr);
    #####:  137:        clientsocket = accept(context->DataSocket, (struct sockaddr *)&laddr, &asz);
    #####:  138:        close(context->DataSocket);
    #####:  139:        context->DataSocket = clientsocket;
        -:  140:
    #####:  141:        if ( clientsocket == INVALID_SOCKET )
        -:  142:            return INVALID_SOCKET;
        -:  143:
    #####:  144:        context->DataIPv4 = 0;
    #####:  145:        context->DataPort = 0;
    #####:  146:        context->Mode = MODE_NORMAL;
    #####:  147:        break;
        -:  148:
        -:  149:    default:
        -:  150:        return INVALID_SOCKET;
        -:  151:    }
        -:  152:    return clientsocket;
        -:  153:}
        -:  154:
      817:  155:ssize_t sendstring(PFTPCONTEXT context, const char *Buffer)
        -:  156:{
      817:  157:    size_t	l = strlen(Buffer);
        -:  158:
      817:  159:    if (context->TLS_session == NULL)
      817:  160:        return (send(context->ControlSocket, Buffer, l, MSG_NOSIGNAL) >= 0);
        -:  161:    else
    #####:  162:        return (gnutls_record_send(context->TLS_session, Buffer, l) >= 0);
        -:  163:}
        -:  164:
    #####:  165:ssize_t sendstring_auto(SOCKET s, gnutls_session_t session, const char *Buffer)
        -:  166:{
    #####:  167:    size_t	l = strlen(Buffer);
        -:  168:
    #####:  169:    if (session == NULL)
    #####:  170:        return (send(s, Buffer, l, MSG_NOSIGNAL) >= 0);
        -:  171:    else
    #####:  172:        return (gnutls_record_send(session, Buffer, l) >= 0);
        -:  173:}
        -:  174:
    #####:  175:ssize_t send_auto(int __fd, gnutls_session_t session, const void *__buf, size_t __n)
        -:  176:{
    #####:  177:    if (session == NULL)
    #####:  178:        return (send(__fd, __buf, __n, MSG_NOSIGNAL));
        -:  179:    else
    #####:  180:        return (gnutls_record_send(session, __buf, __n));
        -:  181:}
        -:  182:
    #####:  183:ssize_t recv_auto(int __fd, gnutls_session_t session, void *__buf, size_t __n)
        -:  184:{
    #####:  185:    if (session == NULL)
    #####:  186:        return (recv(__fd, __buf, __n, 0));
        -:  187:    else
    #####:  188:        return (gnutls_record_recv(session, __buf, __n));
        -:  189:}
        -:  190:
     1633:  191:ssize_t writeconsolestr(const char *Buffer)
        -:  192:{
     1633:  193:    size_t	l = strlen(Buffer);
     1633:  194:    __attribute__((__unused__)) size_t r;
        -:  195:
     1633:  196:    if ( g_log != -1 )
     1633:  197:        r = write(g_log, Buffer, l);
        -:  198:
     1633:  199:    return write(STDOUT_FILENO, Buffer, l);
        -:  200:}
        -:  201:
     1633:  202:int writelogentry(PFTPCONTEXT context, const char *logtext1, const char *logtext2)
        -:  203:{
     1633:  204:    char		text[2*PATH_MAX];
     1633:  205:    time_t		itm = time(NULL);
     1633:  206:    struct tm	ltm;
        -:  207:
     1633:  208:    localtime_r(&itm, &ltm);
        -:  209:
     1633:  210:    if (context == NULL)
        -:  211:    {
     1734:  212:        snprintf(text, sizeof(text), "%02u-%02u-%u %02u:%02u:%02u : %s%s\r\n",
      101:  213:                ltm.tm_mday, ltm.tm_mon+1, ltm.tm_year+1900,
        -:  214:                ltm.tm_hour, ltm.tm_min, ltm.tm_sec, logtext1, logtext2);
        -:  215:    }
        -:  216:    else
        -:  217:    {
     3165:  218:        snprintf(text, sizeof(text), "%02u-%02u-%u %02u:%02u:%02u S-id=%u : %s%s\r\n",
     1532:  219:                ltm.tm_mday, ltm.tm_mon+1, ltm.tm_year+1900,
        -:  220:                ltm.tm_hour, ltm.tm_min, ltm.tm_sec,
        -:  221:                context->SessionID, logtext1, logtext2);
        -:  222:    }
        -:  223:
     1633:  224:    return writeconsolestr(text);
        -:  225:}
        -:  226:
      100:  227:void worker_thread_cleanup(PFTPCONTEXT context)
        -:  228:{
      100:  229:    int					err;
      100:  230:    void				*retv = NULL;
        -:  231:
      100:  232:    if ( context->WorkerThreadValid == 0 ) {
        -:  233:
        -:  234:        /*
        -:  235:         * trying to stop gracefully
        -:  236:         */
    #####:  237:        context->WorkerThreadAbort = 1;
    #####:  238:        sleep(2);
        -:  239:
    #####:  240:        err = pthread_join(context->WorkerThreadId, &retv);
    #####:  241:        if ( err != 0)
        -:  242:        {
    #####:  243:            writelogentry(context, "Enter cancel", "");
    #####:  244:            pthread_cancel(context->WorkerThreadId);
        -:  245:        }
        -:  246:
    #####:  247:        context->WorkerThreadValid = -1;
        -:  248:    }
        -:  249:
      100:  250:    if ( context->DataSocket != INVALID_SOCKET ) {
    #####:  251:        close(context->DataSocket);
    #####:  252:        context->DataSocket = INVALID_SOCKET;
        -:  253:    }
        -:  254:
      100:  255:    if ( context->hFile != -1 ) {
    #####:  256:        close(context->hFile);
    #####:  257:        context->hFile = -1;
        -:  258:    }
        -:  259:
      100:  260:    context->DataIPv4 = 0;
      100:  261:    context->DataPort = 0;
      100:  262:}
        -:  263:
    #####:  264:void worker_thread_start(PFTPCONTEXT context, PSTARTROUTINE fn)
        -:  265:{
    #####:  266:    pthread_t       tid;
    #####:  267:    PTHCONTEXT      tctx;
        -:  268:
    #####:  269:    context->WorkerThreadAbort = 0;
    #####:  270:    pthread_mutex_lock(&context->MTLock);
        -:  271:
    #####:  272:    tctx = x_malloc(sizeof(THCONTEXT));
    #####:  273:    tctx->context = context;
    #####:  274:    tctx->FnType = 0;
    #####:  275:    strcpy(tctx->thFileName, context->FileName);
        -:  276:
    #####:  277:    context->WorkerThreadValid = pthread_create(&tid, NULL, (void * (*)(void *))fn, tctx);
    #####:  278:    if ( context->WorkerThreadValid == 0 )
    #####:  279:        context->WorkerThreadId = tid;
        -:  280:    else
        -:  281:    {
    #####:  282:        free(tctx);
    #####:  283:        sendstring(context, error451);
        -:  284:    }
        -:  285:
    #####:  286:    pthread_mutex_unlock(&context->MTLock);
    #####:  287:}
        -:  288:
      100:  289:int ftpUSER(PFTPCONTEXT context, const char *params)
        -:  290:{
      100:  291:    if ( params == NULL )
    #####:  292:        return sendstring(context, error501);
        -:  293:
      100:  294:    context->Access = FTP_ACCESS_NOT_LOGGED_IN;
        -:  295:
      100:  296:    writelogentry(context, " USER: ", (char *)params);
      100:  297:    snprintf(context->UserName, sizeof(context->UserName), "331 User %s OK. Password required\r\n", params);
      100:  298:    sendstring(context, context->UserName);
        -:  299:
        -:  300:    /* Save login name to UserName for the next PASS command */
      100:  301:    strcpy(context->UserName, params);
      100:  302:    return 1;
        -:  303:}
        -:  304:
       19:  305:int ftpQUIT(PFTPCONTEXT context, const char *params)
        -:  306:{
       19:  307:    char text[PATH_MAX];
        -:  308:
       19:  309:    writelogentry(context, " QUIT", "");
       19:  310:    snprintf(text, sizeof(text), "221 %s\r\n", GOODBYE_MSG);
        -:  311:    /* sendstring(context, success221); */
       19:  312:    sendstring(context, text);
        -:  313:
        -:  314:    /* return 0 to break command processing loop */
       19:  315:    return 0;
        -:  316:}
        -:  317:
    #####:  318:int ftpNOOP(PFTPCONTEXT context, const char *params)
        -:  319:{
    #####:  320:    return sendstring(context, success200);
        -:  321:}
        -:  322:
    #####:  323:int ftpPWD(PFTPCONTEXT context, const char *params)
        -:  324:{
    #####:  325:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####:  326:        return sendstring(context, error530);
        -:  327:
    #####:  328:    snprintf(context->FileName, sizeof(context->FileName), "257 \"%s\" is a current directory.\r\n", context->CurrentDir);
    #####:  329:    return sendstring(context, context->FileName);
        -:  330:}
        -:  331:
      100:  332:int ftpTYPE(PFTPCONTEXT context, const char *params)
        -:  333:{
      100:  334:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####:  335:        return sendstring(context, error530);
        -:  336:
      100:  337:    if (params == NULL)
    #####:  338:        return sendstring(context, error501);
        -:  339:
      100:  340:    switch (*params)
        -:  341:    {
    #####:  342:    case 'A':
        -:  343:    case 'a':
    #####:  344:        return sendstring(context, success200_1);
        -:  345:
      100:  346:    case 'I':
        -:  347:    case 'i':
      100:  348:        return sendstring(context, success200_2);
        -:  349:
    #####:  350:    default:
    #####:  351:        return sendstring(context, error501);
        -:  352:    }
        -:  353:}
        -:  354:
    #####:  355:int ftpPORT(PFTPCONTEXT context, const char *params)
        -:  356:{
    #####:  357:    int			c;
    #####:  358:    in_addr_t	DataIP = 0, DataPort = 0;
    #####:  359:    char		*p = (char *)params;
        -:  360:
    #####:  361:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####:  362:        return sendstring(context, error530);
        -:  363:
    #####:  364:    if ( params == NULL )
    #####:  365:        return sendstring(context, error501);
        -:  366:
    #####:  367:    for (c = 0; c < 4; c++) {
    #####:  368:        DataIP += ((unsigned char)strtoul(p, NULL, 10)) << c*8;
    #####:  369:        while ( (*p >= '0') && (*p <= '9') )
    #####:  370:            p++;
    #####:  371:        if ( *p == 0 )
        -:  372:            break;
    #####:  373:        p++;
        -:  374:    }
        -:  375:
    #####:  376:    for (c = 0; c < 2; c++) {
    #####:  377:        DataPort += ((unsigned char)strtoul(p, NULL, 10)) << c*8;
    #####:  378:        while ( (*p >= '0') && (*p <= '9') )
    #####:  379:            p++;
    #####:  380:        if ( *p == 0 )
        -:  381:            break;
    #####:  382:        p++;
        -:  383:    }
        -:  384:
    #####:  385:    if ( DataIP != context->ClientIPv4 )
    #####:  386:        return sendstring(context, error501);
        -:  387:
    #####:  388:    context->DataIPv4 = DataIP;
    #####:  389:    context->DataPort = DataPort;
    #####:  390:    context->Mode = MODE_NORMAL;
        -:  391:
    #####:  392:    return sendstring(context, success200);
        -:  393:}
        -:  394:
        -:  395:/*
        -:  396:filemode.c -- make a string describing file modes
        -:  397:
        -:  398:  Copyright (C) 1985, 1990, 1993, 1998-2000, 2004, 2006, 2009-2018 Free
        -:  399:  Software Foundation, Inc.
        -:  400: */
        -:  401:
        -:  402:/* Return a character indicating the type of file described by
        -:  403:   file mode BITS:
        -:  404:   '-' regular file
        -:  405:   'b' block special file
        -:  406:   'c' character special file
        -:  407:   'C' high performance ("contiguous data") file
        -:  408:   'd' directory
        -:  409:   'D' door
        -:  410:   'l' symbolic link
        -:  411:   'm' multiplexed file (7th edition Unix; obsolete)
        -:  412:   'n' network special file (HP-UX)
        -:  413:   'p' fifo (named pipe)
        -:  414:   'P' port
        -:  415:   's' socket
        -:  416:   'w' whiteout (4.4BSD)
        -:  417:   '?' some other file type  */
        -:  418:
        -:  419:static char
    #####:  420:ftypelet (mode_t bits)
        -:  421:{
        -:  422:    /* These are the most common, so test for them first.  */
    #####:  423:    if (S_ISREG (bits))
        -:  424:        return '-';
    #####:  425:    if (S_ISDIR (bits))
        -:  426:        return 'd';
        -:  427:
        -:  428:    /* Other letters standardized by POSIX 1003.1-2004.  */
    #####:  429:    if (S_ISBLK (bits))
        -:  430:        return 'b';
    #####:  431:    if (S_ISCHR (bits))
        -:  432:        return 'c';
    #####:  433:    if (S_ISLNK (bits))
        -:  434:        return 'l';
    #####:  435:    if (S_ISFIFO (bits))
        -:  436:        return 'p';
        -:  437:
        -:  438:    /* Other file types (though not letters) standardized by POSIX.  */
    #####:  439:    if (S_ISSOCK (bits))
    #####:  440:        return 's';
        -:  441:
        -:  442:    return '?';
        -:  443:}
        -:  444:
        -:  445:/* Like filemodestring, but rely only on MODE.  */
        -:  446:
        -:  447:void
    #####:  448:strmode (mode_t mode, char *str)
        -:  449:{
    #####:  450:    str[0] = ftypelet (mode);
    #####:  451:    str[1] = mode & S_IRUSR ? 'r' : '-';
    #####:  452:    str[2] = mode & S_IWUSR ? 'w' : '-';
    #####:  453:    str[3] = (mode & S_ISUID
    #####:  454:            ? (mode & S_IXUSR ? 's' : 'S')
    #####:  455:                    : (mode & S_IXUSR ? 'x' : '-'));
    #####:  456:    str[4] = mode & S_IRGRP ? 'r' : '-';
    #####:  457:    str[5] = mode & S_IWGRP ? 'w' : '-';
    #####:  458:    str[6] = (mode & S_ISGID
    #####:  459:            ? (mode & S_IXGRP ? 's' : 'S')
    #####:  460:                    : (mode & S_IXGRP ? 'x' : '-'));
    #####:  461:    str[7] = mode & S_IROTH ? 'r' : '-';
    #####:  462:    str[8] = mode & S_IWOTH ? 'w' : '-';
    #####:  463:    str[9] = (mode & S_ISVTX
    #####:  464:            ? (mode & S_IXOTH ? 't' : 'T')
    #####:  465:                    : (mode & S_IXOTH ? 'x' : '-'));
    #####:  466:    str[10] = ' ';
    #####:  467:    str[11] = '\0';
    #####:  468:}
        -:  469:
        -:  470:/*
        -:  471:	END  filemode.c
        -:  472: */
        -:  473:
    #####:  474:int list_sub (char *dirname, SOCKET s, gnutls_session_t session, struct dirent *entry)
        -:  475:{
    #####:  476:    char			text[2*PATH_MAX], sacl[12];
    #####:  477:    struct stat		filestats;
    #####:  478:    struct tm		ftm_fields;
    #####:  479:    time_t			deltatime;
        -:  480:
    #####:  481:    if (strcmp(entry->d_name, ".") == 0)
        -:  482:        return 1;
    #####:  483:    if (strcmp(entry->d_name, "..") == 0)
        -:  484:        return 1;
        -:  485:
    #####:  486:    snprintf(text, sizeof(text), "%s/%s", dirname, entry->d_name);
        -:  487:
    #####:  488:    if ( lstat(text, &filestats) == 0 )
        -:  489:    {
    #####:  490:        strmode(filestats.st_mode, sacl);
        -:  491:
    #####:  492:        localtime_r(&filestats.st_mtime, &ftm_fields);
    #####:  493:        deltatime = time(NULL) - filestats.st_mtime;
        -:  494:
    #####:  495:        if (deltatime <= 180*24*60*60) {
    #####:  496:            snprintf(text, sizeof(text), "%s %lu %lu %lu %llu %s %02u %02u:%02u %s\r\n",
        -:  497:                    sacl, filestats.st_nlink,
    #####:  498:                    (unsigned long int)filestats.st_uid,
    #####:  499:                    (unsigned long int)filestats.st_gid,
    #####:  500:                    (unsigned long long int)filestats.st_size,
    #####:  501:                    shortmonths[(ftm_fields.tm_mon)], ftm_fields.tm_mday,
        -:  502:                    ftm_fields.tm_hour, ftm_fields.tm_min, entry->d_name);
        -:  503:        }
        -:  504:        else
        -:  505:        {
    #####:  506:            snprintf(text, sizeof(text), "%s %lu %lu %lu %llu %s %02u %02u %s\r\n",
        -:  507:                    sacl, filestats.st_nlink,
    #####:  508:                    (unsigned long int)filestats.st_uid,
    #####:  509:                    (unsigned long int)filestats.st_gid,
    #####:  510:                    (unsigned long long int)filestats.st_size,
    #####:  511:                    shortmonths[(ftm_fields.tm_mon)], ftm_fields.tm_mday,
    #####:  512:                    ftm_fields.tm_year + 1900, entry->d_name);
        -:  513:        }
        -:  514:
        -:  515:    }
        -:  516:
    #####:  517:    return sendstring_auto(s, session, text);
        -:  518:}
        -:  519:
    #####:  520:void *list_thread(PTHCONTEXT tctx)
        -:  521:{
    #####:  522:    volatile SOCKET     clientsocket;
    #####:  523:    gnutls_session_t	TLS_datasession;
    #####:  524:    int					ret;
    #####:  525:    DIR					*pdir;
    #####:  526:    struct dirent		*entry;
    #####:  527:    PFTPCONTEXT         context = tctx->context;
        -:  528:
    #####:  529:    pthread_mutex_lock(&context->MTLock);
    #####:  530:    pthread_cleanup_push(cleanup_handler, tctx);
    #####:  531:    ret = 0;
    #####:  532:    TLS_datasession = NULL;
        -:  533:
    #####:  534:    clientsocket = create_datasocket(context);
    #####:  535:    while (clientsocket != INVALID_SOCKET)
        -:  536:    {
    #####:  537:        if (context->TLS_session != NULL)
    #####:  538:            if (!ftp_init_tls_session(&TLS_datasession, clientsocket, 0))
        -:  539:                break;
        -:  540:
    #####:  541:        pdir = opendir(tctx->thFileName);
    #####:  542:        if (pdir == NULL)
        -:  543:            break;
        -:  544:
    #####:  545:        while ((entry = readdir(pdir)) != NULL) {
    #####:  546:            if (tctx->FnType == LIST_TYPE_MLSD)
    #####:  547:                ret = mlsd_sub(tctx->thFileName, clientsocket, TLS_datasession, entry);
        -:  548:            else
    #####:  549:                ret = list_sub(tctx->thFileName, clientsocket, TLS_datasession, entry);
    #####:  550:            if ( (ret == 0) || (context->WorkerThreadAbort != 0 ))
        -:  551:                break;
        -:  552:        }
        -:  553:
    #####:  554:        closedir(pdir);
        -:  555:        break;
        -:  556:    }
        -:  557:
    #####:  558:    ftp_shutdown_tls_session(TLS_datasession);
        -:  559:
    #####:  560:    writelogentry(context, " LIST/MLSD complete", "");
        -:  561:
    #####:  562:    if (clientsocket == INVALID_SOCKET) {
    #####:  563:        sendstring(context, error451);
        -:  564:    }
        -:  565:    else {
    #####:  566:        if ((context->WorkerThreadAbort == 0) && (ret != 0))
    #####:  567:            sendstring(context, success226);
        -:  568:        else
    #####:  569:            sendstring(context, error426);
        -:  570:
    #####:  571:        close(clientsocket);
    #####:  572:        context->DataSocket = INVALID_SOCKET;
        -:  573:    }
        -:  574:
    #####:  575:    context->WorkerThreadValid = -1;
    #####:  576:    pthread_cleanup_pop(0);
    #####:  577:    free(tctx);
    #####:  578:    pthread_mutex_unlock(&context->MTLock);
    #####:  579:    return NULL;
        -:  580:}
        -:  581:
    #####:  582:int ftpLIST(PFTPCONTEXT context, const char *params)
        -:  583:{
    #####:  584:    struct  stat    filestats;
        -:  585:
    #####:  586:    if (context->Access == FTP_ACCESS_NOT_LOGGED_IN)
    #####:  587:        return sendstring(context, error530);
    #####:  588:    if ((context->WorkerThreadValid == 0) || (context->hFile != -1))
    #####:  589:        return sendstring(context, error550_t);
        -:  590:
    #####:  591:    if (params != NULL)
        -:  592:    {
    #####:  593:        if ((strcmp(params, "-a") == 0) || (strcmp(params, "-l") == 0))
    #####:  594:            params = NULL;
        -:  595:    }
        -:  596:
    #####:  597:    ftp_effective_path(context->RootDir, context->CurrentDir, params, sizeof(context->FileName), context->FileName);
        -:  598:
    #####:  599:    while (stat(context->FileName, &filestats) == 0)
        -:  600:    {
    #####:  601:        if ( !S_ISDIR(filestats.st_mode) )
        -:  602:            break;
        -:  603:
    #####:  604:        sendstring(context, interm150);
    #####:  605:        writelogentry(context, " LIST", (char *)params);
    #####:  606:        worker_thread_start(context, list_thread);
    #####:  607:        return 1;
        -:  608:    }
        -:  609:
    #####:  610:    return sendstring(context, error550);
        -:  611:}
        -:  612:
        -:  613:/*
        -:  614: * Cuts off filename from string leaving only path.
        -:  615: * Return value: pointer to a terminating null character at the end of path
        -:  616: */
        -:  617:
    #####:  618:int ftpCDUP(PFTPCONTEXT context, const char *params)
        -:  619:{
    #####:  620:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####:  621:        return sendstring(context, error530);
        -:  622:
    #####:  623:    if ( strcmp(context->CurrentDir, "/") == 0 )
    #####:  624:        return sendstring(context, success250);
        -:  625:
    #####:  626:    filepath(context->CurrentDir);
        -:  627:
    #####:  628:    writelogentry(context, " CDUP", "");
    #####:  629:    return sendstring(context, success250);
        -:  630:}
        -:  631:
    #####:  632:int ftpCWD(PFTPCONTEXT context, const char *params)
        -:  633:{
    #####:  634:    struct	stat	filestats;
        -:  635:
    #####:  636:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####:  637:        return sendstring(context, error530);
        -:  638:
    #####:  639:    if ( params == NULL )
    #####:  640:        return sendstring(context, error501);
        -:  641:
    #####:  642:    ftp_effective_path(context->RootDir, context->CurrentDir, params, sizeof(context->FileName), context->FileName);
        -:  643:
    #####:  644:    if ( stat(context->FileName, &filestats) == 0 )
    #####:  645:        if ( S_ISDIR(filestats.st_mode) )
        -:  646:        {
    #####:  647:            ftp_effective_path("/", context->CurrentDir, params, sizeof(context->FileName), context->FileName);
    #####:  648:            memset(context->CurrentDir, 0, sizeof(context->CurrentDir));
    #####:  649:            strncpy(context->CurrentDir, context->FileName, sizeof(context->CurrentDir)-1);
    #####:  650:            writelogentry(context, " CWD: ", context->CurrentDir);
    #####:  651:            return sendstring(context, success250);
        -:  652:        }
        -:  653:
    #####:  654:    return sendstring(context, error550);
        -:  655:}
        -:  656:
    #####:  657:void *retr_thread(PTHCONTEXT tctx)
        -:  658:{
    #####:  659:    volatile SOCKET		clientsocket;
    #####:  660:    int					sent_ok, f;
    #####:  661:    off_t				offset;
    #####:  662:    ssize_t				sz, sz_total;
    #####:  663:    size_t				buffer_size;
    #####:  664:    char				*buffer;
    #####:  665:    struct timespec		t;
    #####:  666:    signed long long	lt0, lt1, dtx;
    #####:  667:    gnutls_session_t	TLS_datasession;
    #####:  668:    PFTPCONTEXT         context = tctx->context;
        -:  669:
    #####:  670:    pthread_mutex_lock(&context->MTLock);
    #####:  671:    pthread_cleanup_push(cleanup_handler, context);
        -:  672:
    #####:  673:    f = -1;
    #####:  674:    sent_ok = 0;
    #####:  675:    sz_total = 0;
    #####:  676:    buffer = NULL;
    #####:  677:    TLS_datasession = NULL;
    #####:  678:    clientsocket = INVALID_SOCKET;
    #####:  679:    clock_gettime(CLOCK_MONOTONIC, &t);
    #####:  680:    lt0 = t.tv_sec*1e9 + t.tv_nsec;
    #####:  681:    dtx = t.tv_sec+30;
        -:  682:
    #####:  683:    buffer = malloc(TRANSMIT_BUFFER_SIZE);
    #####:  684:    while (buffer != NULL)
        -:  685:    {
    #####:  686:        clientsocket = create_datasocket(context);
    #####:  687:        if (clientsocket == INVALID_SOCKET)
        -:  688:            break;
        -:  689:
    #####:  690:        if (context->TLS_session != NULL)
        -:  691:        {
    #####:  692:            if (!ftp_init_tls_session(&TLS_datasession, clientsocket, 0))
        -:  693:                break;
        -:  694:
    #####:  695:            buffer_size = gnutls_record_get_max_size(TLS_datasession);
    #####:  696:            if (buffer_size > TRANSMIT_BUFFER_SIZE)
        -:  697:                buffer_size = TRANSMIT_BUFFER_SIZE;
        -:  698:        }
        -:  699:        else
        -:  700:            buffer_size = TRANSMIT_BUFFER_SIZE;
        -:  701:
    #####:  702:        f = open(tctx->thFileName, O_RDONLY);
    #####:  703:        context->hFile = f;
    #####:  704:        if (f == -1)
        -:  705:            break;
        -:  706:
    #####:  707:        offset = lseek(f, context->RestPoint, SEEK_SET);
    #####:  708:        if (offset != context->RestPoint)
        -:  709:            break;
        -:  710:
    #####:  711:        sent_ok = 1;
    #####:  712:        while ( context->WorkerThreadAbort == 0 ) {
    #####:  713:            sz = read(f, buffer, buffer_size);
    #####:  714:            if (sz == 0)
        -:  715:                break;
        -:  716:
    #####:  717:            if (sz < 0)
        -:  718:            {
        -:  719:                sent_ok = 0;
        -:  720:                break;
        -:  721:            }
        -:  722:
    #####:  723:            if (send_auto(clientsocket, TLS_datasession, buffer, sz) == sz)
        -:  724:            {
    #####:  725:                sz_total += sz;
        -:  726:            }
        -:  727:            else
        -:  728:            {
        -:  729:                sent_ok = 0;
        -:  730:                break;
        -:  731:            }
        -:  732:        }
        -:  733:
        -:  734:        /* calculating performance */
        -:  735:
    #####:  736:        clock_gettime(CLOCK_MONOTONIC, &t);
    #####:  737:        lt1 = t.tv_sec*1e9 + t.tv_nsec;
    #####:  738:        dtx = lt1 - lt0;
        -:  739:
    #####:  740:        context->Stats.DataTx += sz_total;
    #####:  741:        ++context->Stats.FilesTx;
        -:  742:
    #####:  743:        snprintf(buffer, buffer_size, " RETR complete. %zd bytes (%f MBytes) total sent in %f seconds (%f MBytes/s)",
    #####:  744:                sz_total, sz_total/1048576.0f, dtx/1000000000.0f, (1000000000.0f*sz_total)/dtx/1048576.0f);
    #####:  745:        writelogentry(context, buffer, "");
        -:  746:
        -:  747:        break;
        -:  748:    }
        -:  749:
    #####:  750:    if (f != -1)
    #####:  751:        close(f);
        -:  752:
    #####:  753:    context->hFile = -1;
        -:  754:
    #####:  755:    if (buffer != NULL) {
    #####:  756:        free(buffer);
        -:  757:    }
        -:  758:
    #####:  759:    ftp_shutdown_tls_session(TLS_datasession);
        -:  760:
    #####:  761:    if (clientsocket == INVALID_SOCKET) {
    #####:  762:        sendstring(context, error451);
        -:  763:    }
        -:  764:    else {
    #####:  765:        if ((context->WorkerThreadAbort == 0) && (sent_ok != 0))
    #####:  766:            sendstring(context, success226);
        -:  767:        else
    #####:  768:            sendstring(context, error426);
        -:  769:
    #####:  770:        close(clientsocket);
    #####:  771:        context->DataSocket = INVALID_SOCKET;
        -:  772:    }
        -:  773:
    #####:  774:    context->WorkerThreadValid = -1;
    #####:  775:    pthread_cleanup_pop(0);
    #####:  776:    free(tctx);
    #####:  777:    pthread_mutex_unlock(&context->MTLock);
    #####:  778:    return NULL;
        -:  779:}
        -:  780:
    #####:  781:int ftpRETR(PFTPCONTEXT context, const char *params)
        -:  782:{
    #####:  783:    struct	stat	filestats;
        -:  784:
    #####:  785:    if (context->Access == FTP_ACCESS_NOT_LOGGED_IN)
    #####:  786:        return sendstring(context, error530);
    #####:  787:    if ( params == NULL )
    #####:  788:        return sendstring(context, error501);
    #####:  789:    if ((context->WorkerThreadValid == 0) || (context->hFile != -1))
    #####:  790:        return sendstring(context, error550_t);
        -:  791:
    #####:  792:    ftp_effective_path(context->RootDir, context->CurrentDir, params, sizeof(context->FileName), context->FileName);
        -:  793:
    #####:  794:    while (stat(context->FileName, &filestats) == 0)
        -:  795:    {
    #####:  796:        if ( !S_ISREG(filestats.st_mode) )
        -:  797:            break;
        -:  798:
    #####:  799:        sendstring(context, interm150);
    #####:  800:        writelogentry(context, " RETR: ", (char *)params);
    #####:  801:        worker_thread_start(context, retr_thread);
    #####:  802:        return 1;
        -:  803:    }
        -:  804:
    #####:  805:    return sendstring(context, error550);
        -:  806:}
        -:  807:
    #####:  808:int ftpABOR(PFTPCONTEXT context, const char *params)
        -:  809:{
    #####:  810:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####:  811:        return sendstring(context, error530);
        -:  812:
    #####:  813:    writelogentry(context, " ABORT command", NULL);
    #####:  814:    worker_thread_cleanup(context);
    #####:  815:    return sendstring(context, success226);
        -:  816:}
        -:  817:
    #####:  818:int ftpDELE(PFTPCONTEXT context, const char *params)
        -:  819:{
    #####:  820:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####:  821:        return sendstring(context, error530);
    #####:  822:    if ( context->Access < FTP_ACCESS_FULL )
    #####:  823:        return sendstring(context, error550_r);
    #####:  824:    if ( params == NULL )
    #####:  825:        return sendstring(context, error501);
        -:  826:
    #####:  827:    ftp_effective_path(context->RootDir, context->CurrentDir, params, sizeof(context->FileName), context->FileName);
        -:  828:
    #####:  829:    if ( unlink(context->FileName) == 0 ) {
    #####:  830:        sendstring(context, success250);
    #####:  831:        writelogentry(context, " DELE: ", (char *)params);
        -:  832:    }
        -:  833:    else
    #####:  834:        sendstring(context, error550_r);
        -:  835:
        -:  836:    return 1;
        -:  837:}
        -:  838:
    #####:  839:int pasv(PFTPCONTEXT context)
        -:  840:{
    #####:  841:    SOCKET				datasocket;
    #####:  842:    struct sockaddr_in	laddr;
    #####:  843:    int					socketret = -1, result = 0;
    #####:  844:    unsigned long		c;
    #####:  845:    struct	timespec	rtctime;
        -:  846:
    #####:  847:    while (1)
        -:  848:    {
    #####:  849:        if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
        -:  850:        {
    #####:  851:            sendstring(context, error530);
    #####:  852:            break;
        -:  853:        }
        -:  854:
    #####:  855:        if ( context->WorkerThreadValid == 0 )
        -:  856:        {
    #####:  857:            sendstring(context, error550_t);
    #####:  858:            break;
        -:  859:        }
        -:  860:
    #####:  861:        if ( context->DataSocket != INVALID_SOCKET )
    #####:  862:            close(context->DataSocket);
        -:  863:
    #####:  864:        context->DataSocket = INVALID_SOCKET;
        -:  865:
    #####:  866:        datasocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    #####:  867:        if (datasocket == INVALID_SOCKET)
        -:  868:        {
    #####:  869:            sendstring(context, error451);
    #####:  870:            break;
        -:  871:        }
        -:  872:
    #####:  873:        for (c = g_cfg.PasvPortBase; c <= g_cfg.PasvPortMax; c++) {
    #####:  874:            clock_gettime(CLOCK_REALTIME, &rtctime);
    #####:  875:            memset(&laddr, 0, sizeof(laddr));
    #####:  876:            laddr.sin_family = AF_INET;
    #####:  877:            laddr.sin_port = htons((in_port_t)(g_cfg.PasvPortBase +
        -:  878:                    (rtctime.tv_nsec % (g_cfg.PasvPortMax-g_cfg.PasvPortBase))));
    #####:  879:            laddr.sin_addr.s_addr = context->ServerIPv4;
    #####:  880:            socketret = bind(datasocket, (struct sockaddr *)&laddr, sizeof(laddr));
    #####:  881:            if ( socketret == 0 )
        -:  882:                break;
        -:  883:        }
        -:  884:
    #####:  885:        if ( socketret != 0 ) {
    #####:  886:            close(datasocket);
    #####:  887:            sendstring(context, error451);
    #####:  888:            break;
        -:  889:        }
        -:  890:
    #####:  891:        socketret = listen(datasocket, SOMAXCONN);
    #####:  892:        if (socketret != 0) {
    #####:  893:            close(datasocket);
    #####:  894:            sendstring(context, error451);
    #####:  895:            break;
        -:  896:        }
        -:  897:
    #####:  898:        if ((context->ClientIPv4 & g_cfg.LocalIPMask) == (context->ServerIPv4 & g_cfg.LocalIPMask))
        -:  899:        {
    #####:  900:            context->DataIPv4 = context->ServerIPv4;
    #####:  901:            writelogentry(context, " local client.", "");
        -:  902:        } else {
    #####:  903:            context->DataIPv4 = g_cfg.ExternalInterface;
    #####:  904:            writelogentry(context, " nonlocal client.", "");
        -:  905:        }
        -:  906:
    #####:  907:        context->DataPort = laddr.sin_port;
    #####:  908:        context->DataSocket = datasocket;
    #####:  909:        context->Mode = MODE_PASSIVE;
        -:  910:
    #####:  911:        result = 1;
    #####:  912:        break;
        -:  913:    }
        -:  914:
    #####:  915:    return result;
        -:  916:}
        -:  917:
    #####:  918:int ftpEPSV (PFTPCONTEXT context, const char *params)
        -:  919:{
    #####:  920:    if (pasv(context) == 0)
        -:  921:        return 1;
        -:  922:
    #####:  923:    snprintf(context->FileName, sizeof(context->FileName),
        -:  924:            "229 Entering Extended Passive Mode (|||%u|)\r\n",
    #####:  925:            ntohs(context->DataPort));
        -:  926:
    #####:  927:    writelogentry(context, " entering extended passive mode", "");
        -:  928:
    #####:  929:    return sendstring(context, context->FileName);
        -:  930:}
        -:  931:
    #####:  932:int ftpPASV(PFTPCONTEXT context, const char *params)
        -:  933:{
    #####:  934:    if (pasv(context) == 0)
        -:  935:        return 1;
        -:  936:
    #####:  937:    snprintf(context->FileName, sizeof(context->FileName),
        -:  938:            "227 Entering Passive Mode (%u,%u,%u,%u,%u,%u).\r\n",
        -:  939:            context->DataIPv4 & 0xff,
    #####:  940:            (context->DataIPv4 >> 8) & 0xff,
    #####:  941:            (context->DataIPv4 >> 16) & 0xff,
    #####:  942:            (context->DataIPv4 >> 24) & 0xff,
        -:  943:            context->DataPort & 0xff,
    #####:  944:            (context->DataPort >> 8) & 0xff);
        -:  945:
    #####:  946:    writelogentry(context, " entering passive mode", "");
        -:  947:
    #####:  948:    return sendstring(context, context->FileName);
        -:  949:}
        -:  950:
      100:  951:int ftpPASS(PFTPCONTEXT context, const char *params)
        -:  952:{
      100:  953:    char	temptext[256];
        -:  954:
      100:  955:    if ( params == NULL )
    #####:  956:        return sendstring(context, error501);
        -:  957:
      100:  958:    memset(temptext, 0, sizeof(temptext));
        -:  959:
        -:  960:    /*
        -:  961:     * we have login name saved in context->UserName from USER command
        -:  962:     */
      100:  963:    if (!config_parse(g_cfg.ConfigFile, context->UserName, "pswd", temptext, sizeof(temptext)))
    #####:  964:        return sendstring(context, error530_r);
        -:  965:
     100*:  966:    if ( (strcmp(temptext, params) == 0) || (temptext[0] == '*') )
        -:  967:    {
      100:  968:        memset(context->RootDir, 0, sizeof(context->RootDir));
      100:  969:        memset(temptext, 0, sizeof(temptext));
        -:  970:
      100:  971:        config_parse(g_cfg.ConfigFile, context->UserName, "root", context->RootDir, sizeof(context->RootDir));
      100:  972:        config_parse(g_cfg.ConfigFile, context->UserName, "accs", temptext, sizeof(temptext));
        -:  973:
      100:  974:        context->Access = FTP_ACCESS_NOT_LOGGED_IN;
      200:  975:        do {
        -:  976:
      100:  977:            if ( strcasecmp(temptext, "admin") == 0 ) {
      100:  978:                context->Access = FTP_ACCESS_FULL;
      100:  979:                break;
        -:  980:            }
        -:  981:
    #####:  982:            if ( strcasecmp(temptext, "upload") == 0 ) {
    #####:  983:                context->Access = FTP_ACCESS_CREATENEW;
    #####:  984:                break;
        -:  985:            }
        -:  986:
    #####:  987:            if ( strcasecmp(temptext, "readonly") == 0 ) {
    #####:  988:                context->Access = FTP_ACCESS_READONLY;
    #####:  989:                break;
        -:  990:            }
        -:  991:
    #####:  992:            return sendstring(context, error530_b);
        -:  993:        } while (0);
        -:  994:
      100:  995:        writelogentry(context, " PASS->successful logon", "");
        -:  996:    }
        -:  997:    else
    #####:  998:        return sendstring(context, error530_r);
        -:  999:
      100: 1000:    return sendstring(context, success230);
        -: 1001:}
        -: 1002:
    #####: 1003:int ftpREST(PFTPCONTEXT context, const char *params)
        -: 1004:{
    #####: 1005:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####: 1006:        return sendstring(context, error530);
        -: 1007:
    #####: 1008:    if ( params == NULL )
    #####: 1009:        return sendstring(context, error501);
        -: 1010:
    #####: 1011:    context->RestPoint = strtoull(params, NULL, 10);
    #####: 1012:    snprintf(context->FileName, sizeof(context->FileName),
        -: 1013:            "350 REST supported. Ready to resume at byte offset %llu\r\n",
        -: 1014:            (unsigned long long int)context->RestPoint);
        -: 1015:
    #####: 1016:    return sendstring(context, context->FileName);
        -: 1017:}
        -: 1018:
    #####: 1019:int ftpSIZE(PFTPCONTEXT context, const char *params)
        -: 1020:{
    #####: 1021:    struct stat		filestats;
        -: 1022:
    #####: 1023:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####: 1024:        return sendstring(context, error530);
    #####: 1025:    if ( params == NULL )
    #####: 1026:        return sendstring(context, error501);
        -: 1027:
    #####: 1028:    ftp_effective_path(context->RootDir, context->CurrentDir, params, sizeof(context->FileName), context->FileName);
        -: 1029:
    #####: 1030:    if ( stat(context->FileName, &filestats) == 0 )
        -: 1031:    {
    #####: 1032:        snprintf(context->FileName, sizeof(context->FileName), "213 %llu\r\n",
    #####: 1033:                (unsigned long long int)filestats.st_size);
    #####: 1034:        sendstring(context, context->FileName);
        -: 1035:    }
        -: 1036:    else
    #####: 1037:        sendstring(context, error550);
        -: 1038:
        -: 1039:    return 1;
        -: 1040:}
        -: 1041:
      100: 1042:int ftpMKD(PFTPCONTEXT context, const char *params)
        -: 1043:{
      100: 1044:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####: 1045:        return sendstring(context, error530);
      100: 1046:    if ( context->Access < FTP_ACCESS_CREATENEW )
    #####: 1047:        return sendstring(context, error550_r);
      100: 1048:    if ( params == NULL )
    #####: 1049:        return sendstring(context, error501);
        -: 1050:
      100: 1051:    ftp_effective_path(context->RootDir, context->CurrentDir, params, sizeof(context->FileName), context->FileName);
        -: 1052:
      100: 1053:    if ( mkdir(context->FileName, 0755) == 0 ) {
       98: 1054:        sendstring(context, success257);
       98: 1055:        writelogentry(context, " MKD: ", (char *)params);
        -: 1056:    }
        -: 1057:    else
        2: 1058:        sendstring(context, error550_r);
        -: 1059:
        -: 1060:    return 1;
        -: 1061:}
        -: 1062:
       98: 1063:int ftpRMD(PFTPCONTEXT context, const char *params)
        -: 1064:{
       98: 1065:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####: 1066:        return sendstring(context, error530);
       98: 1067:    if ( context->Access < FTP_ACCESS_FULL )
    #####: 1068:        return sendstring(context, error550_r);
       98: 1069:    if ( params == NULL )
    #####: 1070:        return sendstring(context, error501);
        -: 1071:
       98: 1072:    ftp_effective_path(context->RootDir, context->CurrentDir, params, sizeof(context->FileName), context->FileName);
        -: 1073:
       98: 1074:    if ( rmdir(context->FileName) == 0 ) {
       98: 1075:        sendstring(context, success250);
       98: 1076:        writelogentry(context, " DELE: ", (char *)params);
        -: 1077:    }
        -: 1078:    else
    #####: 1079:        sendstring(context, error550_r);
        -: 1080:
        -: 1081:    return 1;
        -: 1082:}
        -: 1083:
    #####: 1084:void *stor_thread(PTHCONTEXT tctx)
        -: 1085:{
    #####: 1086:    volatile SOCKET     clientsocket;
    #####: 1087:    int					f;
    #####: 1088:    ssize_t				wsz, sz, sz_total;
    #####: 1089:    size_t				buffer_size;
    #####: 1090:    char				*buffer;
    #####: 1091:    struct timespec		t;
    #####: 1092:    signed long long	lt0, lt1, dtx;
    #####: 1093:    gnutls_session_t	TLS_datasession;
    #####: 1094:    PFTPCONTEXT         context = tctx->context;
        -: 1095:
    #####: 1096:    pthread_mutex_lock(&context->MTLock);
    #####: 1097:    pthread_cleanup_push(cleanup_handler, tctx);
        -: 1098:
    #####: 1099:    f = -1;
    #####: 1100:    sz_total = 0;
    #####: 1101:    buffer = NULL;
    #####: 1102:    TLS_datasession = NULL;
    #####: 1103:    clientsocket = INVALID_SOCKET;
    #####: 1104:    clock_gettime(CLOCK_MONOTONIC, &t);
    #####: 1105:    lt0 = t.tv_sec*1e9 + t.tv_nsec;
    #####: 1106:    dtx = t.tv_sec+30;
        -: 1107:
    #####: 1108:    buffer = malloc(TRANSMIT_BUFFER_SIZE);
    #####: 1109:    while (buffer != NULL)
        -: 1110:    {
    #####: 1111:        clientsocket = create_datasocket(context);
    #####: 1112:        if (clientsocket == INVALID_SOCKET)
        -: 1113:            break;
        -: 1114:
    #####: 1115:        if (context->TLS_session != NULL)
        -: 1116:        {
    #####: 1117:            if (!ftp_init_tls_session(&TLS_datasession, clientsocket, 0))
        -: 1118:                break;
        -: 1119:
    #####: 1120:            buffer_size = gnutls_record_get_max_size(TLS_datasession);
    #####: 1121:            if (buffer_size > TRANSMIT_BUFFER_SIZE)
        -: 1122:                buffer_size = TRANSMIT_BUFFER_SIZE;
        -: 1123:        }
        -: 1124:        else
        -: 1125:            buffer_size = TRANSMIT_BUFFER_SIZE;
        -: 1126:
    #####: 1127:        if (tctx->FnType == STOR_TYPE_APPEND)
    #####: 1128:            f = open(tctx->thFileName, O_RDWR);
        -: 1129:        else
    #####: 1130:            f = open(tctx->thFileName, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
        -: 1131:
    #####: 1132:        context->hFile = f;
    #####: 1133:        if (f == -1)
        -: 1134:            break;
        -: 1135:
    #####: 1136:        lseek(f, 0, SEEK_END);
        -: 1137:
    #####: 1138:        while ( context->WorkerThreadAbort == 0 ) {
    #####: 1139:            sz = recv_auto(clientsocket, TLS_datasession, buffer, buffer_size);
    #####: 1140:            if (sz > 0)
        -: 1141:            {
    #####: 1142:                sz_total += sz;
    #####: 1143:                wsz = write(f, buffer, sz);
    #####: 1144:                if (wsz != sz)
        -: 1145:                    break;
        -: 1146:            }
        -: 1147:            else
        -: 1148:                break;
        -: 1149:        }
        -: 1150:
        -: 1151:        /* calculating performance */
        -: 1152:
    #####: 1153:        clock_gettime(CLOCK_MONOTONIC, &t);
    #####: 1154:        lt1 = t.tv_sec*1e9 + t.tv_nsec;
    #####: 1155:        dtx = lt1 - lt0;
        -: 1156:
    #####: 1157:        context->Stats.DataRx += sz_total;
    #####: 1158:        ++context->Stats.FilesRx;
        -: 1159:
    #####: 1160:        snprintf(buffer, buffer_size, " STOR/APPEND complete. %zd bytes (%f MBytes) total sent in %f seconds (%f MBytes/s)",
    #####: 1161:                sz_total, sz_total/1048576.0f, dtx/1000000000.0f, (1000000000.0f*sz_total)/dtx/1048576.0f);
    #####: 1162:        writelogentry(context, buffer, "");
        -: 1163:
        -: 1164:        break;
        -: 1165:    }
        -: 1166:
    #####: 1167:    if (f != -1)
    #####: 1168:        close(f);
        -: 1169:
    #####: 1170:    context->hFile = -1;
        -: 1171:
    #####: 1172:    if (buffer != NULL) {
    #####: 1173:        free(buffer);
        -: 1174:    }
        -: 1175:
    #####: 1176:    ftp_shutdown_tls_session(TLS_datasession);
        -: 1177:
    #####: 1178:    if (clientsocket == INVALID_SOCKET) {
    #####: 1179:        sendstring(context, error451);
        -: 1180:    }
        -: 1181:    else {
    #####: 1182:        if (context->WorkerThreadAbort == 0)
    #####: 1183:            sendstring(context, success226);
        -: 1184:        else
    #####: 1185:            sendstring(context, error426);
        -: 1186:
    #####: 1187:        close(clientsocket);
    #####: 1188:        context->DataSocket = INVALID_SOCKET;
        -: 1189:    }
        -: 1190:
    #####: 1191:    context->WorkerThreadValid = -1;
    #####: 1192:    pthread_cleanup_pop(0);
    #####: 1193:    free(tctx);
    #####: 1194:    pthread_mutex_unlock(&context->MTLock);
    #####: 1195:    return NULL;
        -: 1196:}
        -: 1197:
    #####: 1198:int ftpSTOR(PFTPCONTEXT context, const char *params)
        -: 1199:{
    #####: 1200:    struct  stat    filestats;
        -: 1201:
    #####: 1202:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####: 1203:        return sendstring(context, error530);
    #####: 1204:    if ( context->Access < FTP_ACCESS_CREATENEW )
    #####: 1205:        return sendstring(context, error550_r);
    #####: 1206:    if ( params == NULL )
    #####: 1207:        return sendstring(context, error501);
    #####: 1208:    if ((context->WorkerThreadValid == 0) || (context->hFile != -1))
    #####: 1209:        return sendstring(context, error550_t);
        -: 1210:
    #####: 1211:    ftp_effective_path(context->RootDir, context->CurrentDir, params, sizeof(context->FileName), context->FileName);
        -: 1212:
        -: 1213:    /* check: do not overwrite existing files if not full access */
    #####: 1214:    if ( stat(context->FileName, &filestats) == 0 )
        -: 1215:    {
    #####: 1216:        if ( context->Access != FTP_ACCESS_FULL )
    #####: 1217:            return sendstring(context, error550_r);
        -: 1218:        /* is it a regular file? */
    #####: 1219:        if ( !S_ISREG(filestats.st_mode) )
    #####: 1220:            return sendstring(context, error550);
        -: 1221:    }
        -: 1222:
    #####: 1223:    sendstring(context, interm150);
    #####: 1224:    writelogentry(context, " STOR: ", (char *)params);
    #####: 1225:    worker_thread_start(context, stor_thread);
    #####: 1226:    return 1;
        -: 1227:}
        -: 1228:
      100: 1229:int ftpSYST(PFTPCONTEXT context, const char *params)
        -: 1230:{
      100: 1231:    return sendstring(context, success215);
        -: 1232:}
        -: 1233:
    #####: 1234:int ftpHELP(PFTPCONTEXT context, const char *params)
        -: 1235:{
    #####: 1236:    return sendstring(context, success214);
        -: 1237:}
        -: 1238:
    #####: 1239:int isoctaldigit(char c)
        -: 1240:{
    #####: 1241:    return ((c >= '0') && (c < '8'));
        -: 1242:}
        -: 1243:
    #####: 1244:int parseCHMOD(PFTPCONTEXT context, const char* params)
        -: 1245:{
    #####: 1246:    mode_t flags = 0;
        -: 1247:
    #####: 1248:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####: 1249:        return sendstring(context, error530);
    #####: 1250:    if ( context->Access < FTP_ACCESS_FULL )
    #####: 1251:        return sendstring(context, error550_r);
        -: 1252:
    #####: 1253:    while (isoctaldigit(*params))
        -: 1254:    {
    #####: 1255:        flags <<= 3;
    #####: 1256:        flags += ((unsigned int)*params) - (unsigned int)'0';
    #####: 1257:        ++params;
        -: 1258:    }
        -: 1259:
    #####: 1260:    if (*params != ' ')
        -: 1261:        return 0;
        -: 1262:
    #####: 1263:    while (*params == ' ')
    #####: 1264:        ++params;
        -: 1265:
    #####: 1266:    ftp_effective_path(context->RootDir, context->CurrentDir, params, sizeof(context->FileName), context->FileName);
    #####: 1267:    return (chmod(context->FileName, flags) == 0);
        -: 1268:}
        -: 1269:
    #####: 1270:int ftpSITE(PFTPCONTEXT context, const char *params)
        -: 1271:{
    #####: 1272:    if ( params != NULL )
        -: 1273:    {
    #####: 1274:        if (strcasecmp(params, "help") == 0)
    #####: 1275:            return sendstring(context, "200 chmod\r\n");
        -: 1276:
    #####: 1277:        if (strncasecmp(params, "chmod ", 6) == 0)
        -: 1278:        {
    #####: 1279:            if (parseCHMOD(context, &params[6]))
    #####: 1280:                return sendstring(context, "200 chmod OK\r\n");
        -: 1281:
    #####: 1282:            return sendstring(context, error501);
        -: 1283:        }
        -: 1284:    }
        -: 1285:
    #####: 1286:    return sendstring(context, error500);
        -: 1287:}
        -: 1288:
      100: 1289:int ftpFEAT(PFTPCONTEXT context, const char *params)
        -: 1290:{
      100: 1291:    return sendstring(context, success211);
        -: 1292:}
        -: 1293:
    #####: 1294:void *append_thread(PTHCONTEXT tctx)
        -: 1295:{
    #####: 1296:    tctx->FnType = STOR_TYPE_APPEND;
    #####: 1297:    return stor_thread(tctx);
        -: 1298:}
        -: 1299:
    #####: 1300:int ftpAPPE(PFTPCONTEXT context, const char *params)
        -: 1301:{
    #####: 1302:    struct	stat	filestats;
        -: 1303:
    #####: 1304:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####: 1305:        return sendstring(context, error530);
    #####: 1306:    if ( context->Access < FTP_ACCESS_FULL )
    #####: 1307:        return sendstring(context, error550_r);
    #####: 1308:    if ( params == NULL )
    #####: 1309:        return sendstring(context, error501);
    #####: 1310:    if ((context->WorkerThreadValid == 0) || (context->hFile != -1))
    #####: 1311:        return sendstring(context, error550_t);
        -: 1312:
    #####: 1313:    ftp_effective_path(context->RootDir, context->CurrentDir, params, sizeof(context->FileName), context->FileName);
        -: 1314:
        -: 1315:    /* stat must NOT fail */
    #####: 1316:    while (stat(context->FileName, &filestats) == 0)
        -: 1317:    {
        -: 1318:        /* do not try to "append" for directories */
    #####: 1319:        if ( !S_ISREG(filestats.st_mode) )
        -: 1320:            break;
        -: 1321:
    #####: 1322:        sendstring(context, interm150);
    #####: 1323:        writelogentry(context, " APPE: ", (char *)params);
    #####: 1324:        worker_thread_start(context, append_thread);
    #####: 1325:        return 1;
        -: 1326:    }
        -: 1327:
    #####: 1328:    return sendstring(context, error550);
        -: 1329:}
        -: 1330:
    #####: 1331:int ftpRNFR(PFTPCONTEXT context, const char *params)
        -: 1332:{
    #####: 1333:    struct stat		filestats;
        -: 1334:
    #####: 1335:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####: 1336:        return sendstring(context, error530);
    #####: 1337:    if ( context->Access < FTP_ACCESS_FULL )
    #####: 1338:        return sendstring(context, error550_r);
    #####: 1339:    if ( params == NULL )
    #####: 1340:        return sendstring(context, error501);
        -: 1341:
    #####: 1342:    ftp_effective_path(context->RootDir, context->CurrentDir, params, sizeof(context->RnFrom), context->RnFrom);
        -: 1343:
    #####: 1344:    if ( stat(context->RnFrom, &filestats) == 0 )
        -: 1345:    {
    #####: 1346:        writelogentry(context, " RNFR: ", context->RnFrom);
    #####: 1347:        sendstring(context, interm350_ren);
        -: 1348:    }
        -: 1349:    else
    #####: 1350:        sendstring(context, error550);
        -: 1351:
        -: 1352:    return 1;
        -: 1353:}
        -: 1354:
    #####: 1355:int ftpRNTO(PFTPCONTEXT context, const char *params)
        -: 1356:{
    #####: 1357:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####: 1358:        return sendstring(context, error530);
    #####: 1359:    if ( context->Access < FTP_ACCESS_FULL )
    #####: 1360:        return sendstring(context, error550_r);
    #####: 1361:    if ( params == NULL )
    #####: 1362:        return sendstring(context, error501);
        -: 1363:
    #####: 1364:    ftp_effective_path(context->RootDir, context->CurrentDir, params, sizeof(context->FileName), context->FileName);
    #####: 1365:    if ( rename(context->RnFrom, context->FileName) == 0 )
        -: 1366:    {
    #####: 1367:        writelogentry(context, " RNTO: ", context->FileName);
    #####: 1368:        sendstring(context, success250);
        -: 1369:    }
        -: 1370:    else
    #####: 1371:        sendstring(context, error550);
        -: 1372:
    #####: 1373:    memset(&context->RnFrom, 0, sizeof(context->RnFrom));
    #####: 1374:    return 1;
        -: 1375:}
        -: 1376:
    #####: 1377:int ftpOPTS(PFTPCONTEXT context, const char *params)
        -: 1378:{
    #####: 1379:    if ( params != NULL )
    #####: 1380:        if (strcasecmp(params, "utf8 on") == 0)
    #####: 1381:            return sendstring(context, "200 Always in UTF8 mode.\r\n");
        -: 1382:
    #####: 1383:    writelogentry(context, " unsupported OPTS: ", params);
    #####: 1384:    return sendstring(context, error500);
        -: 1385:}
        -: 1386:
    #####: 1387:int ftpAUTH(PFTPCONTEXT context, const char *params)
        -: 1388:{
    #####: 1389:    if ( params == NULL )
    #####: 1390:        return sendstring(context, error501);
        -: 1391:
    #####: 1392:    if ( strcasecmp(params, "TLS") == 0 )
        -: 1393:    {
        -: 1394:        /* ftp_init_tls_session will send a status reply */
    #####: 1395:        ftp_init_tls_session(&context->TLS_session, context->ControlSocket, 1);
    #####: 1396:        return 1;
        -: 1397:    }
        -: 1398:    else
    #####: 1399:        return sendstring(context, error504);
        -: 1400:}
        -: 1401:
    #####: 1402:int ftpPBSZ (PFTPCONTEXT context, const char *params)
        -: 1403:{
    #####: 1404:    if ( params == NULL )
    #####: 1405:        return sendstring(context, error501);
        -: 1406:
    #####: 1407:    if ( context->TLS_session == NULL )
    #####: 1408:        return sendstring(context, error503);
        -: 1409:
    #####: 1410:    context->BlockSize = strtoul(params, NULL, 10);
    #####: 1411:    return sendstring(context, success200);
        -: 1412:}
        -: 1413:
    #####: 1414:int ftpPROT (PFTPCONTEXT context, const char *params)
        -: 1415:{
    #####: 1416:    if ( context->Access == FTP_ACCESS_NOT_LOGGED_IN )
    #####: 1417:        return sendstring(context, error530);
        -: 1418:
    #####: 1419:    if ( params == NULL )
    #####: 1420:        return sendstring(context, error501);
        -: 1421:
    #####: 1422:    if ( context->TLS_session == NULL )
    #####: 1423:        return sendstring(context, error503);
        -: 1424:
    #####: 1425:    switch (*params)
        -: 1426:    {
    #####: 1427:    case 'C':
    #####: 1428:        context->DataProtectionLevel = 0;
    #####: 1429:        return sendstring(context, success200);
    #####: 1430:        break;
        -: 1431:
    #####: 1432:    case 'P':
    #####: 1433:        context->DataProtectionLevel = 100;
    #####: 1434:        return sendstring(context, success200);
    #####: 1435:        break;
        -: 1436:
    #####: 1437:    default:
    #####: 1438:        return sendstring(context, error504);
        -: 1439:    }
        -: 1440:}
        -: 1441:
    #####: 1442:int mlsd_sub (char *dirname, SOCKET s, gnutls_session_t session, struct dirent *entry)
        -: 1443:{
    #####: 1444:    char			text[2*PATH_MAX], *entrytype, *sizetype;
    #####: 1445:    struct stat		filestats;
    #####: 1446:    struct tm		ftm_fields;
        -: 1447:
    #####: 1448:    if (strcmp(entry->d_name, ".") == 0)
        -: 1449:        return 1;
    #####: 1450:    if (strcmp(entry->d_name, "..") == 0)
        -: 1451:        return 1;
        -: 1452:
    #####: 1453:    snprintf(text, sizeof(text), "%s/%s", dirname, entry->d_name);
        -: 1454:
    #####: 1455:    if ( lstat(text, &filestats) == 0 )
        -: 1456:    {
    #####: 1457:        if ( S_ISDIR(filestats.st_mode) )
        -: 1458:        {
        -: 1459:            entrytype = "dir";
        -: 1460:            sizetype = "sizd";
        -: 1461:        }
        -: 1462:        else
        -: 1463:        {
    #####: 1464:            entrytype = "file";
    #####: 1465:            sizetype = "size";
        -: 1466:        }
        -: 1467:
    #####: 1468:        if (S_ISLNK(filestats.st_mode))
        -: 1469:        {
    #####: 1470:            entrytype = "OS.unix=slink";
        -: 1471:        }
        -: 1472:
    #####: 1473:        localtime_r(&filestats.st_mtime, &ftm_fields);
    #####: 1474:        ++ftm_fields.tm_mon;
        -: 1475:
    #####: 1476:        snprintf(text, sizeof(text),
        -: 1477:                "type=%s;%s=%llu;UNIX.mode=%lo;UNIX.owner=%lu;UNIX.group=%lu;modify=%u%02u%02u%02u%02u%02u; %s\r\n",
        -: 1478:                entrytype, sizetype,
    #####: 1479:                (unsigned long long int)filestats.st_size,
    #####: 1480:                (unsigned long int)filestats.st_mode,
    #####: 1481:                (unsigned long int)filestats.st_uid,
    #####: 1482:                (unsigned long int)filestats.st_gid,
    #####: 1483:                ftm_fields.tm_year + 1900, ftm_fields.tm_mon, ftm_fields.tm_mday,
        -: 1484:                ftm_fields.tm_hour, ftm_fields.tm_min, ftm_fields.tm_sec, entry->d_name
        -: 1485:        );
        -: 1486:    }
        -: 1487:
    #####: 1488:    return sendstring_auto(s, session, text);
        -: 1489:}
        -: 1490:
    #####: 1491:void *mlsd_thread(PTHCONTEXT tctx)
        -: 1492:{
    #####: 1493:    tctx->FnType = LIST_TYPE_MLSD;
    #####: 1494:    return list_thread(tctx);
        -: 1495:}
        -: 1496:
    #####: 1497:int ftpMLSD(PFTPCONTEXT context, const char *params)
        -: 1498:{
    #####: 1499:    struct  stat    filestats;
        -: 1500:
    #####: 1501:    if (context->Access == FTP_ACCESS_NOT_LOGGED_IN)
    #####: 1502:        return sendstring(context, error530);
    #####: 1503:    if ((context->WorkerThreadValid == 0) || (context->hFile != -1))
    #####: 1504:        return sendstring(context, error550_t);
        -: 1505:
    #####: 1506:    ftp_effective_path(context->RootDir, context->CurrentDir, params, sizeof(context->FileName), context->FileName);
        -: 1507:
    #####: 1508:    while (stat(context->FileName, &filestats) == 0)
        -: 1509:    {
    #####: 1510:        if ( !S_ISDIR(filestats.st_mode) )
        -: 1511:            break;
        -: 1512:
    #####: 1513:        sendstring(context, interm150);
    #####: 1514:        writelogentry(context, " MLSD-LIST ", (char *)params);
    #####: 1515:        worker_thread_start(context, mlsd_thread);
    #####: 1516:        return 1;
        -: 1517:    }
        -: 1518:
    #####: 1519:    return sendstring(context, error550);
        -: 1520:}
        -: 1521:
      798: 1522:int recvcmd(PFTPCONTEXT context, char *buffer, size_t buffer_size)
        -: 1523:{
      798: 1524:    ssize_t	l, p = 0;
        -: 1525:
      798: 1526:    if ( buffer_size < 5 )
        -: 1527:        return 0;
        -: 1528:
      798: 1529:    memset(buffer, 0, buffer_size);
      798: 1530:    --buffer_size;
        -: 1531:
      798: 1532:    while (buffer_size > 0)
        -: 1533:    {
      798: 1534:        if (context->TLS_session == NULL)
      798: 1535:            l = recv(context->ControlSocket, buffer+p, buffer_size, 0);
        -: 1536:        else
    #####: 1537:            l = gnutls_record_recv(context->TLS_session, buffer+p, buffer_size);
        -: 1538:
      798: 1539:        if ( l <= 0 )
        -: 1540:            return 0;
        -: 1541:
      717: 1542:        buffer_size -= l;
      717: 1543:        p += l;
        -: 1544:
      717: 1545:        if ( p >= 2 )
      717: 1546:            if ( (buffer[p-2] == '\r') && (buffer[p-1] == '\n') )
        -: 1547:            {
      717: 1548:                buffer[p-2] = 0;
      717: 1549:                return 1;
        -: 1550:            }
        -: 1551:    }
        -: 1552:
        -: 1553:    return 0;
        -: 1554:}
        -: 1555:
      100: 1556:void *ftp_client_thread(SOCKET s)
        -: 1557:{
      100: 1558:    FTPCONTEXT				ctx __attribute__ ((aligned (16)));
      100: 1559:    char					*cmd, *params, rcvbuf[PATH_MAX];
      100: 1560:    int						c, cmdno, rv, tn;
      100: 1561:    size_t					i, cmdlen;
      100: 1562:    socklen_t				asz;
      100: 1563:    struct sockaddr_in		laddr;
      100: 1564:    pthread_mutexattr_t		m_attr;
        -: 1565:
      100: 1566:    memset(&rcvbuf, 0, sizeof(rcvbuf));
      100: 1567:    memset(&ctx, 0, sizeof(ctx));
        -: 1568:
      100: 1569:    ctx.Access = FTP_ACCESS_NOT_LOGGED_IN;
      100: 1570:    ctx.ControlSocket = s;
      100: 1571:    ctx.SessionID = __sync_add_and_fetch(&g_newid, 1);
      100: 1572:    tn = __sync_add_and_fetch(&g_threads, 1);
      100: 1573:    snprintf(rcvbuf, sizeof(rcvbuf), "<- New thread. Thread counter g_threads=%i", tn);
      100: 1574:    writelogentry(&ctx, rcvbuf, "");
        -: 1575:
      100: 1576:    memset(&laddr, 0, sizeof(laddr));
      100: 1577:    asz = sizeof(laddr);
      100: 1578:    while ( getsockname(ctx.ControlSocket, (struct sockaddr *)&laddr, &asz) == 0 )
        -: 1579:    {
      100: 1580:        ctx.ServerIPv4 = laddr.sin_addr.s_addr;
        -: 1581:
      100: 1582:        memset(&laddr, 0, sizeof(laddr));
      100: 1583:        asz = sizeof(laddr);
      100: 1584:        if ( getpeername(ctx.ControlSocket, (struct sockaddr *)&laddr, &asz) != 0 )
        -: 1585:            break;
        -: 1586:
      100: 1587:        ctx.ClientIPv4 = laddr.sin_addr.s_addr;
      100: 1588:        ctx.Mode = MODE_NORMAL;
      100: 1589:        ctx.WorkerThreadAbort = 1;
      100: 1590:        ctx.WorkerThreadValid = -1;
      100: 1591:        ctx.hFile = -1;
      100: 1592:        ctx.DataSocket = INVALID_SOCKET;
        -: 1593:
      100: 1594:        pthread_mutexattr_init(&m_attr);
        -: 1595:#if defined(PTHREAD_MUTEX_RECURSIVE) || defined(__FreeBSD__)
        -: 1596:        pthread_mutexattr_settype(&m_attr, PTHREAD_MUTEX_RECURSIVE);
        -: 1597:#else
      100: 1598:        pthread_mutexattr_settype(&m_attr, PTHREAD_MUTEX_RECURSIVE_NP);
        -: 1599:#endif
      100: 1600:        pthread_mutex_init(&ctx.MTLock, &m_attr);
        -: 1601:
      100: 1602:        ctx.CurrentDir[0] = '/';
      100: 1603:        sendstring(&ctx, success220);
        -: 1604:
      100: 1605:        memset(&rcvbuf, 0, sizeof(rcvbuf));
        -: 1606:
      100: 1607:        snprintf(rcvbuf, sizeof(rcvbuf), "<- New user IP=%u.%u.%u.%u:%u",
        -: 1608:                laddr.sin_addr.s_addr & 0xff,
      100: 1609:                (laddr.sin_addr.s_addr >> 8 ) & 0xff,
      100: 1610:                (laddr.sin_addr.s_addr >> 16 ) & 0xff,
      100: 1611:                (laddr.sin_addr.s_addr >> 24 ) & 0xff,
      100: 1612:                ntohs(laddr.sin_port)
        -: 1613:        );
        -: 1614:
      100: 1615:        writelogentry(&ctx, rcvbuf, "");
        -: 1616:
      798: 1617:        while ( ctx.ControlSocket != INVALID_SOCKET ) {
      798: 1618:            if ( !recvcmd(&ctx, rcvbuf, sizeof(rcvbuf)) )
        -: 1619:                break;
        -: 1620:
        -: 1621:            i = 0;
      717: 1622:            while ((rcvbuf[i] != 0) && (isalpha(rcvbuf[i]) == 0))
    #####: 1623:                ++i;
        -: 1624:
      717: 1625:            cmd = &rcvbuf[i];
     3387: 1626:            while ((rcvbuf[i] != 0) && (rcvbuf[i] != ' '))
     2670: 1627:                ++i;
        -: 1628:
      717: 1629:            cmdlen = &rcvbuf[i] - cmd;
     1215: 1630:            while (rcvbuf[i] == ' ')
      498: 1631:                ++i;
        -: 1632:
      717: 1633:            if (rcvbuf[i] == 0)
        -: 1634:                params = NULL;
        -: 1635:            else
      498: 1636:                params = &rcvbuf[i];
        -: 1637:
      717: 1638:            cmdno = -1;
      717: 1639:            rv = 1;
     9602: 1640:            for (c=0; c<MAX_CMDS; c++)
     9602: 1641:                if (strncasecmp(cmd, ftpprocs[c].Name, cmdlen) == 0)
        -: 1642:                {
      717: 1643:                    cmdno = c;
      717: 1644:                    rv = ftpprocs[c].Proc(&ctx, params);
      717: 1645:                    break;
        -: 1646:                }
        -: 1647:
      717: 1648:            if ( cmdno != FTP_PASSCMD_INDEX )
      617: 1649:                writelogentry(&ctx, " @@ CMD: ", rcvbuf);
        -: 1650:            else
      100: 1651:                writelogentry(&ctx, " @@ CMD: ", "PASS ***");
        -: 1652:
      717: 1653:            if ( cmdno == -1 )
    #####: 1654:                sendstring(&ctx, error500);
        -: 1655:
      717: 1656:            if ( rv <= 0 )
        -: 1657:                break;
      100: 1658:        };
        -: 1659:
      100: 1660:        worker_thread_cleanup(&ctx);
        -: 1661:
      100: 1662:        pthread_mutex_destroy(&ctx.MTLock);
      100: 1663:        pthread_mutexattr_destroy(&m_attr);
      100: 1664:        snprintf(rcvbuf, sizeof(rcvbuf),
        -: 1665:            " User disconnected. \n==== Session %u statistics ====\n"
        -: 1666:            "Rx: %zd bytes (%f MBytes) total received by server in %zd files,\n"
        -: 1667:            "Tx: %zd bytes (%f MBytes) total sent to the client in %zd files.\n",
        -: 1668:            ctx.SessionID,
      100: 1669:            ctx.Stats.DataRx, ctx.Stats.DataRx / 1048576.0f, ctx.Stats.FilesRx,
      100: 1670:            ctx.Stats.DataTx, ctx.Stats.DataTx / 1048576.0f, ctx.Stats.FilesTx);
        -: 1671:
      100: 1672:        writelogentry(&ctx, rcvbuf, "");
      100: 1673:        break;
        -: 1674:    }
        -: 1675:
      100: 1676:    ftp_shutdown_tls_session(ctx.TLS_session);
        -: 1677:
      100: 1678:    close(ctx.ControlSocket);
      100: 1679:    __sync_add_and_fetch(&g_client_sockets_closed, 1);
      100: 1680:    tn = __sync_sub_and_fetch(&g_threads, 1);
      100: 1681:    snprintf(rcvbuf, sizeof(rcvbuf), "<- Thread exit. Thread counter g_threads=%i", tn);
      100: 1682:    writelogentry(&ctx, rcvbuf, "");
        -: 1683:
      100: 1684:    return NULL;
        -: 1685:}
        -: 1686:
      100: 1687:void socket_set_keepalive(int s) {
      100: 1688:    int opt = 1;
        -: 1689:
      100: 1690:    if (setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &opt, sizeof(opt)) != 0)
        -: 1691:    {
    #####: 1692:        printf("\r\n SO_KEEPALIVE set failed.\r\n");
    #####: 1693:        return;
        -: 1694:    }
        -: 1695:
      100: 1696:    opt = 16; /* set idle status after 16 seconds since last data transfer */;
      100: 1697:    setsockopt(s, IPPROTO_TCP, TCP_KEEPIDLE, &opt, sizeof(opt));
        -: 1698:
      100: 1699:    opt = 16; /* send keep alive packet every 16 seconds */
      100: 1700:    setsockopt(s, IPPROTO_TCP, TCP_KEEPINTVL, &opt, sizeof(opt));
        -: 1701:
      100: 1702:    opt = 8; /* drop after 8 unanswered packets */
      100: 1703:    setsockopt(s, IPPROTO_TCP, TCP_KEEPCNT, &opt, sizeof(opt));
        -: 1704:}
        -: 1705:
        1: 1706:void *ftpmain(void *p)
        -: 1707:{
        1: 1708:    struct  sockaddr_in laddr;
        -: 1709:
        1: 1710:    int     ftpsocket = INVALID_SOCKET,
        -: 1711:            clientsocket,
        -: 1712:            socketret,
        -: 1713:            rv;
        -: 1714:
        1: 1715:    socklen_t       asz;
        1: 1716:    pthread_t       th;
        1: 1717:    char            text[512];
        -: 1718:
        1: 1719:    ftpsocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        1: 1720:    if ( ftpsocket == INVALID_SOCKET )
        -: 1721:    {
    #####: 1722:        printf("\r\n socket create error\r\n");
    #####: 1723:        return 0;
        -: 1724:    }
        -: 1725:
        1: 1726:    rv = 1;
        1: 1727:    setsockopt(ftpsocket, SOL_SOCKET, SO_REUSEADDR, &rv, sizeof(rv));
        -: 1728:
        1: 1729:    memset(&laddr, 0, sizeof(laddr));
        1: 1730:    laddr.sin_family = AF_INET;
        1: 1731:    laddr.sin_port = htons(g_cfg.Port);
        1: 1732:    laddr.sin_addr.s_addr = g_cfg.BindToInterface;
        1: 1733:    socketret = bind(ftpsocket, (struct sockaddr *)&laddr, sizeof(laddr));
        1: 1734:    if  ( socketret != 0 ) {
    #####: 1735:        printf("\r\n Failed to start server. Can not bind to address\r\n\r\n");
    #####: 1736:        close(ftpsocket);
    #####: 1737:        return 0;
        -: 1738:    }
        -: 1739:
        1: 1740:    writelogentry(NULL, success220, "");
        -: 1741:
        1: 1742:    socketret = listen(ftpsocket, SOMAXCONN);
      101: 1743:    while ( socketret == 0 ) {
        -: 1744:
      101: 1745:        memset(&laddr, 0, sizeof(laddr));
      101: 1746:        asz = sizeof(laddr);
      101: 1747:        clientsocket = accept(ftpsocket, (struct sockaddr *)&laddr, &asz);
     100*: 1748:        if (clientsocket == INVALID_SOCKET)
    #####: 1749:            continue;
        -: 1750:
      100: 1751:        __sync_add_and_fetch(&g_client_sockets_created, 1);
        -: 1752:
      100: 1753:        rv = -1;
      100: 1754:        if (g_threads < g_cfg.MaxUsers)
        -: 1755:        {
      100: 1756:            if (g_cfg.EnableKeepalive != 0)
      100: 1757:                socket_set_keepalive(clientsocket);
        -: 1758:
      100: 1759:            rv = pthread_create(&th, NULL, (void * (*)(void *))ftp_client_thread, (void *)clientsocket);
      100: 1760:            if (rv != 0)
    #####: 1761:                sendstring_plaintext(clientsocket, error451);
        -: 1762:        }
        -: 1763:        else
        -: 1764:        {
    #####: 1765:            sendstring_plaintext(clientsocket, error451_max);
        -: 1766:        }
        -: 1767:
      100: 1768:        if (rv != 0)
        -: 1769:        {
    #####: 1770:            close(clientsocket);
    #####: 1771:            __sync_add_and_fetch(&g_client_sockets_closed, 1);
        -: 1772:        }
        -: 1773:
      100: 1774:        snprintf(text, sizeof(text),
        -: 1775:                "MAIN LOOP stats: g_threads=%i, g_cfg.MaxUsers=%i, g_client_sockets_created=%llu, g_client_sockets_closed=%llu\r\n",
        -: 1776:                g_threads, g_cfg.MaxUsers, g_client_sockets_created, g_client_sockets_closed);
        -: 1777:
      100: 1778:        writelogentry(NULL, text, "");
        -: 1779:    }
        -: 1780:
    #####: 1781:    close(ftpsocket);
        -: 1782:
    #####: 1783:    return NULL;
        -: 1784:}
